# Instrucciones de Arquitectura y Desarrollo para GitHub Copilot

Actúa como un Arquitecto de Software Senior especializado en React, TypeScript y Rendimiento. Sigue estas directrices estrictamente para cada sugerencia de código.

## 1. Contexto del Proyecto
- **Framework:** React 18 + Vite.
- **Lenguaje:** TypeScript (Modo Estricto).
- **Estado Global:** Zustand (con patrón de inmutabilidad).
- **Estilos:** CSS Modules (*.module.css).
- **Arquitectura:** Feature-Slicing (features/grading, shared/ui).

## 2. Reglas de Estilo de Código
- **Naming:**
  - Componentes: `PascalCase` (ej. `GradingPanel`).
  - Funciones/Variables: `camelCase`.
  - Constantes: `UPPER_SNAKE_CASE`.
- **TypeScript:**
  - NO usar `any`. Definir interfaces o tipos explícitos en archivos `types.ts`.
  - Preferir `interface` sobre `type` para definiciones de objetos extensibles.
- **Sintaxis:**
  - Usar `const` para todas las declaraciones de variables.
  - Componentes funcionales siempre tipados con `React.FC<Props>`.

## 3. Gestión de Estado (Zustand)
- **Inmutabilidad:** NUNCA mutar el estado directamente.
  - ❌ `state.usuario.nombre = 'Juan'`
  - ✅ `set((state) => ({ usuario: { ...state.usuario, nombre: 'Juan' } }))`
- **Selectores:** Al consumir el store en componentes, SIEMPRE usar selectores atómicos o `useShallow` para evitar re-renderizados innecesarios.
  - ✅ `const { data } = useStore(useShallow(state => ({ data: state.data })))`

## 4. Rendimiento y Reactividad
- **Memoización:**
  - Utilizar `React.memo` para componentes UI puros (Botones, Inputs, Iconos) que reciben props primitivos.
  - Utilizar `useCallback` para funciones pasadas como props a componentes hijos.
  - Utilizar `useMemo` para cálculos costosos o transformaciones de arrays/objetos derivados del store.
- **Renderizado:** Evitar definir componentes dentro de otros componentes.

## 5. Restricciones de Modificación
- **Props vs Contexto:** NO agregar nuevos props a componentes intermedios para pasar datos a través de múltiples niveles (*prop drilling*).
  - Si un dato se necesita a más de 2 niveles de profundidad, DEBE moverse al Store de Zustand o usar un Contexto local.
- **Archivos:** No crear archivos nuevos sin verificar si la funcionalidad ya existe en `shared/utils` o `hooks`.

## 6. CSS Modules
- Mantener los estilos locales al componente.
- No usar selectores de ID (`#id`) en CSS Modules.
- Usar nombres de clase sem# Instrucciones de Arquitectura y Desarrollo para GitHub Copilot

Actúa como un Arquitecto de Software Senior especializado en React, TypeScript y Rendimiento. Sigue estas directrices estrictamente para cada sugerencia de código.

## 1. Contexto del Proyecto
- **Framework:** React 18 + Vite.
- **Lenguaje:** TypeScript (Modo Estricto).
- **Estado Global:** Zustand (con patrón de inmutabilidad).
- **Estilos:** CSS Modules (*.module.css).
- **Arquitectura:** Feature-Slicing (features/grading, shared/ui).

## 2. Reglas de Estilo de Código
- **Naming:**
  - Componentes: `PascalCase` (ej. `GradingPanel`).
  - Funciones/Variables: `camelCase`.
  - Constantes: `UPPER_SNAKE_CASE`.
- **TypeScript:**
  - NO usar `any`. Definir interfaces o tipos explícitos en archivos `types.ts`.
  - Preferir `interface` sobre `type` para definiciones de objetos extensibles.
- **Sintaxis:**
  - Usar `const` para todas las declaraciones de variables.
  - Componentes funcionales siempre tipados con `React.FC<Props>`.

## 3. Gestión de Estado (Zustand)
- **Inmutabilidad:** NUNCA mutar el estado directamente.
  - ❌ `state.usuario.nombre = 'Juan'`
  - ✅ `set((state) => ({ usuario: { ...state.usuario, nombre: 'Juan' } }))`
- **Selectores:** Al consumir el store en componentes, SIEMPRE usar selectores atómicos o `useShallow` para evitar re-renderizados innecesarios.
  - ✅ `const { data } = useStore(useShallow(state => ({ data: state.data })))`

## 4. Rendimiento y Reactividad
- **Memoización:**
  - Utilizar `React.memo` para componentes UI puros (Botones, Inputs, Iconos) que reciben props primitivos.
  - Utilizar `useCallback` para funciones pasadas como props a componentes hijos.
  - Utilizar `useMemo` para cálculos costosos o transformaciones de arrays/objetos derivados del store.
- **Renderizado:** Evitar definir componentes dentro de otros componentes.

## 5. Restricciones de Modificación
- **Props vs Contexto:** NO agregar nuevos props a componentes intermedios para pasar datos a través de múltiples niveles (*prop drilling*).
  - Si un dato se necesita a más de 2 niveles de profundidad, DEBE moverse al Store de Zustand o usar un Contexto local.
- **Archivos:** No crear archivos nuevos sin verificar si la funcionalidad ya existe en `shared/utils` o `hooks`.

## 6. CSS Modules
- Mantener los estilos locales al componente.
- No usar selectores de ID (`#id`) en CSS Modules.
- Usar nombres de clase semánticos (.container, .active, .error).